# -*- coding: utf-8 -*-
"""Jogo_da_velha.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YD_wEEUb5cL94_fSzfRGibcTpKR7ZC5l
"""

from ipywidgets import Button, VBox, HBox, Layout

from functools import partial
class Interface:  # Creating interface for the Game
    def __init__(self):
      self.buttons = [
          Button(description='',
                 layout=Layout(width='100px', height='100px'))
          for _ in range(9)
      ]
      self.grid = VBox([
          HBox(self.buttons[(i*3):(i*3)+3])
          for i in range(3)
      ])

      self.link_clicks()
      self.current_user = 'X'

    def on_set_position(self, i , button):
      if not button.description:
        button.description = self.current_user
        self.current_user = 'O' if self.current_user == 'X' else 'X'

    def link_clicks(self):
      for i, button in enumerate(self.buttons):
        button.on_click(partial(self.on_set_position, i))

interface = Interface()
interface.grid

import numpy as np

def get_empty_spaces(board):  # Getting all the empty spaces

  empty_spaces = []

  for i, row in enumerate(board):
    for j, item in enumerate(row):
      if item == 0:
        empty_spaces.append((i, j))

  return empty_spaces

def get_game_possibilities(board, player):

    empty_spaces = get_empty_spaces(board)
    possible_boards = []

    for row, col in empty_spaces:
        new_board = board.copy()
        new_board[row, col] = player
        possible_boards.append(new_board)

    return possible_boards

board = np.zeros(shape=(3, 3))
get_game_possibilities(board, 1)

def get_game_status(board):
    for row in board:
        if sum(row) in {-3, 3}:
            return True, sum(row) // 3

    for col in board.T:
        if sum(col) in {-3, 3}:
            return True, sum(col) // 3

    if sum(np.diagonal(board)) in {-3, 3}:
        return True, sum(col) // 3


    if sum(np.diagonal(np.fliplr(board))) in {-3, 3}:
        return True, sum(col) // 3

    if not get_empty_spaces(board):
        return True, None

    return False, None

def score(winner, deepth):
    return 0

def get_game_graph(board, player, deepth):
    is_over, winner = get_game_status(board)
    if is_over:
        return score(winner, deepth)

    moviments = get_game_possibilities(board, player, deepth+1)
    new_player = -1 if player == 1 else 1
    current_score = 0
    best_moviment = None
    for new_board in moviments:
        move_score = get_game_graph(new_board, new_player)

        if move_score > current_score:
            current_score = move_score
            best_moviment = new_board